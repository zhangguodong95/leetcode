## [403. 青蛙过河](https://leetcode-cn.com/problems/frog-jump/)

一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。

给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。

如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。

**请注意：**

- 石子的数量 ≥ 2 且 < 1100；
- 每一个石子的位置序号都是一个非负整数，且其 < 231；
- 第一个石子的位置永远是0。

**示例 1:**

```
[0,1,3,5,6,8,12,17]

总共有8个石子。
第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,
第三个石子在序号为3的单元格的位置， 以此定义整个数组...
最后一个石子处于序号为17的单元格的位置。

返回 true。即青蛙可以成功过河，按照如下方案跳跃： 
跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着 
跳2个单位到第4块石子, 然后跳3个单位到第6块石子, 
跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）
```

**示例 2:**

```
[0,1,2,3,4,8,9,11]

返回 false。青蛙没有办法过河。 
这是因为第5和第6个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。
```

### 算法分析

```
使用动态规划
1.重复性  
2.状态空间 dp[i][k] 表示能否从第j（0,i-1)块石头通过k步跳到第i块石头上
3.状态方程
if(k<=i)
dp[i][k] == dp[j][k-1]||dp[j][k+1]||dp[j][k]

1.j-1 如果能够通过 k -1 , k + 1, 或者 k 补跳到 j 上 那么，j 到 i 的跳跃就能实现
2.假设一直都是跳最大步数，第0块石头跳到第1块石头是1步，第1到第二最多是2步，那么第i块石头最多可以i+ 1 步
```

### 代码实现

```java
//小青蛙过河
    public boolean canCross(int[] stones) {
        if (stones.length <= 1 || stones == null) return false;
        int n = stones.length;
        if (stones[1] != 1) return false;
		//防止dp[j][k+1] 越界
        boolean[][] dp = new boolean[n][n + 1];//dp[i][k]表示第i个小石头 能否通过前一个小石头j通过k步跳达
        dp[0][0] = true;

        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                int k = stones[i] - stones[j];
                //小于等于才用判断 否则直接就是false 具体解释看思路分析
                if (k <= i) {
                    //最终要得到 dp[len -1][k]的值
                    dp[i][k] = dp[j][k - 1] || dp[j][k] || dp[j][k + 1];
                    //不同的j k也是不同的 所以最后一步的dp[i][k]可能也会有多个 但是我们只要一个满足就可以判断了
                    //这里加入提前结束的判断
                    if (i == n - 1 && dp[i][k]) {
                        return true;
                    }
                }
            }
        }
        //所有情况都遍历完了
        return false;
    }
```

